---
title: "Longitudinal Data"
author: "Eric R. Scott"
date: "2021-06-02"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(lubridate)
library(patchwork)
library(lme4)
library(performance)
library(broom)
library(broom.mixed)

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# Purpose

What is the goal of this notebook?

# Load Data

```{r data, echo=TRUE}
longdata <- read_rds(here("data", "clean_data", "longdata.rds"))
```

## Data Dictionary

Use `df_dict(df)` to automatically insert a template markdown data dictionary at the location of your cursor

# Analysis

Figure 2: As facets:

```{r}
ggplot(longdata, aes(x = date, y = height)) +
  stat_summary(aes(color = hist_treat, linetype = curr_treat), geom = "line", fun = "mean") +
  facet_wrap(~species, scales = "free_y", ncol = 1) +
  scale_x_datetime("", date_breaks = "1 week", date_labels = "%m/%d") +
  scale_y_continuous("Height (cm)") +
  scale_color_discrete("Historical") +
  scale_linetype_discrete("Current") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

# Determine cutoffs

Kale continues growing throughout the season, but beans and oats both stop growing after a few weeks.
I think it is reasonable to just "eyeball" the point at which they stop growing, and look at growth rates before that point (the alternative would be a logistic or changepoint model---[logistic](https://bscheng.com/2014/05/07/modeling-logistic-growth-data-in-r/) might be worth looking into).
Then, I'll calculate a daily growth to hopefully reduce heteroskedasticity and remove "week" from the model, thus simplifying it.

```{r}
#split data
beans <- longdata %>% filter(species == "beans")
kale <- longdata %>% filter(species == "kale")
oats <- longdata %>% filter(species == "oats")
```

## Beans

```{r}
ggplot(beans, aes(x = date, y = height)) +
  stat_summary(aes(color = hist_treat, linetype = curr_treat), geom = "line", fun = "mean") +
  scale_x_datetime("", date_breaks = "1 week", date_labels = "%m/%d") +
  scale_y_continuous("Height (cm)") +
  scale_color_discrete("Historical") +
  scale_linetype_discrete("Current") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Looks like 7/31 would be a good cutoff.

```{r}
beans_2 <- beans %>% filter(date <= ymd("2018-07-31"))
```

## Oats

```{r}
ggplot(oats, aes(x = date, y = height)) +
  stat_summary(aes(color = hist_treat, linetype = curr_treat), geom = "line", fun = "mean") +
  scale_x_datetime("", date_breaks = "1 week", date_labels = "%m/%d") +
  scale_y_continuous("Height (cm)") +
  scale_color_discrete("Historical") +
  scale_linetype_discrete("Current") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Less clear for oats---it seems like the end of growth depends on the treatment with oats in current dry conditions not really leveling off in size until the very end and in current ambient conditions growth is leveling off by 8/07.

# Growth rate

Wait, before cutting off dates, let's calculate growth rate and see how that looks.

```{r}
longdata_2 <-
  longdata %>%
  group_by(species, plant_id) %>%
  arrange(date) %>% 
  mutate(growth = height - lag(height))


ggplot(longdata_2, aes(y = growth, x = date, color = hist_treat, linetype = curr_treat)) +
  stat_summary(geom = "line", fun = "mean") +
  stat_summary(geom = "point", fun = "mean", aes(shape = hist_treat)) +
  facet_wrap(~species) +
  scale_x_datetime("", date_breaks = "1 week", date_labels = "%m/%d")


ggplot(longdata_2, aes(growth)) + geom_histogram() + facet_wrap(~species)

```

raw data is pretty normally distributed, but growth clearly depends on date for beans and oats.
So seems like some cutoffs would be useful if the goal is really to get rid of "date" as a co-variate.
Could just include date and deal with 3-way interaction?
Could look into timeseries methods?

I think it might be best to go from after initial herbivory (ask when `july_herbivory_count` happened) to just before growth levels off for **all treatments**.
Then say, oats and beans showed logistic growth patterns, but we were only interested in the linear growth phase and in final heights.

One set of models for growth \~ curr_treat\*hist_treat + july_herbivory_count

then with final harvest data do mass \~ .
or final_heigth \~ .

# Models

```{r}
long_list <-
  longdata_2 %>%
  group_by(species) %>%
  group_split()

beans <- long_list[[1]]
kale <- long_list[[2]]
oats <- long_list[[3]]
```

start with kale because it keeps growing the whole time

## Height & time

```{r}
hist(kale$height) #nonnormal
hist(log(kale$height)) #normal except for a few small values

m_ht <-
  lmer(
    log(height) ~ days*hist_treat*curr_treat + july_herbivory_count +
      (1|plot_id) + (1|pot_id),
    data = kale
  )

check_normality(m_ht)
performance::check_heteroscedasticity(m_ht)
performance::check_model(m_ht, check = c("linearity", "qq", "normality", "homogeneity"))
```

Check for significance of random effects

```{r}
m2 <- update(m_ht, .~. - (1|pot_id))
m3 <- update(m_ht, .~. -(1|plot_id))
bbmle::AICtab(m_ht, m2, m3)
```

pot ID, but not plot ID significant.
Might as well keep both though.

```{r}
car::Anova(m_ht)
```

Not very satisfying results, difficult to interpret

## Growth
```{r}
hist(kale$growth) #leptokurtic
```

```{r}
m_gr <- 
  lmer(
    growth ~ hist_treat*curr_treat + july_herbivory_count +
      (1|plot_id) + (1|pot_id), 
    data = kale
  )
summary(m_gr) #plot ID non significant again, variance = 0
```


```{r}
check_normality(m_gr)
performance::check_heteroscedasticity(m_gr)
performance::check_model(m_gr, check = c("linearity", "qq", "normality", "homogeneity"))
```

Not worried about homogeneity of variance, but kurtosis is real bad.

```{r}
car::Anova(m_gr)
```

## Growth with family = scat
The Scaled t family is appropriate for leptokurtic distributions, but only available in `mgcv::gam()` as far as I know. Fortunately, `gam()` can fit random effects.

```{r}
library(mgcv)
library(gratia)
gam_gr <-
  mgcv::gam(growth ~ hist_treat*curr_treat + july_herbivory_count +
              s(plot_id, bs = "re") + s(pot_id, bs = "re"),
      data = kale %>% filter(!is.na(growth)),
      family = scat)

AIC(gam_gr, m_gr)

gratia::appraise(gam_gr)
```
seems better

```{r}
anova(gam_gr)
```

nothing significant.

